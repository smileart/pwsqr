#! /usr/bin/env ruby

require 'docopt'
require 'clipboard'
require 'yaml'
require 'logger'
require 'open3'
require 'colorize'
require 'open-uri'
require 'onetime/api'

require_relative '../lib/pwsqr.rb'

# 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧 ☢️ UNDER CONSTRUCTION! ☢️ 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧

# Public: main CLI interface class
# Process args, executes external binaries
class PwsQR
  attr_reader :clipboard_backup

  CONFIG_PATH = "#{Dir.home}/.#{PwsQrEnv::NAME}".freeze
  ONETIME_SIGNUP_URL = 'https://onetimesecret.com/signup'.blue.freeze
  ONETIME_SECRET_BASE_URL = 'https://onetimesecret.com/secret/'.freeze

  # \x0 hack fixes Docopt first line indentation issue!!!
  DOCOPT = <<-"DOC".freeze
    \x0
    ======================================================
            Command-line QR tool for PWS gem 📲
    ======================================================

    Usage:
      #{PwsQrEnv::NAME} [--offline | --email] [--namespace <namespace>] <key>
      #{PwsQrEnv::NAME} --version
      #{PwsQrEnv::NAME} --help
      #{PwsQrEnv::NAME} --init

    Options:
      --version, -v                              Show the current app version
      --help, -h                                 Show this screen
      --init                                     Initialise new configuration
      --namespace <namespace>, -n <namespace>    Use custom pws namespace
      --offline, -o                              Force local password usage (disable OneTimeSecret if configured,
                                                 mind the length of the password)
      --email, -e                                Send a friendly email containing the secret link
  DOC

  INITDOC = <<-"INITDOC".freeze
    Initialising configuration… #{CONFIG_PATH.yellow}

    In order to use pwsqr online, please create your account here: #{ONETIME_SIGNUP_URL}
    and setup your settings in #{CONFIG_PATH.yellow} config file. Thanks! >^.^<

    If you really wanted to use it offline — run the command with `--offline` flag!
  INITDOC

  CONFIG_DEFAULTS = {
    onetime: {
      email: nil,
      api_key: nil
    },
    url_shortening: {
      url: 'https://clck.ru/--?url='
    }
  }.freeze

  ERROR_MESSAGES = {
    onetime_wrong_response: 'One-Time Secret didn\'t respond properly!',
    url_shortener_wrong_response: 'URL shortener didn\'t respond properly!',
    network_error: 'Network error occurred (probably there is no internet connection)!'
  }.freeze

  def initialize(logger_class, logger_device, logger_level)
    @logger = logger_class.new(logger_device)
    @logger.level = logger_level
  end

  def run
    @clipboard_backup = Clipboard.paste

    @docopt = Docopt.docopt(DOCOPT)
    @docopt['--namespace'] = @docopt['--namespace'] ? "-#{@docopt['--namespace']}" : ''
    @pws_command = "pws #{@docopt['--namespace']} get #{@docopt['<key>']} 0"

    load_config

    version if @docopt['--version']
    init_config if @docopt['--init']
    pwsqr if @docopt['<key>']
  end

  def error(message)
    puts "ERROR: #{message}".red
  end

  private

  def pws
    exit unless system(@pws_command)
  end

  def pwsqr
    if !config? || @docopt['--offline']
      pws_offline
    else
      pws_online
    end
  end

  def init_config
    @config ||= CONFIG_DEFAULTS
    File.open(CONFIG_PATH, 'w').write(@config.to_yaml)

    print INITDOC
    exit
  end

  def version
    puts "#{PwsQrEnv::NAME.upcase} v.#{PwsQrEnv::VERSION}"
    exit
  end

  def load_config
    if File.exist?(CONFIG_PATH)
      @config ||= YAML.load_file(CONFIG_PATH)
    else
      init_config
    end
  end

  def config?
    onetime_conf = @config[:onetime]

    @config &&
      onetime_conf[:email] &&
      onetime_conf[:api_key] &&
      !@config[:url_shortening][:url].empty?
  end

  def generate_qr(str)
    result = nil

    Open3.popen3('qrcli', str) { |_i, output, _e, _t| result = output.read }

    print result
    exit
  end

  def shorten_url(url)
    url = open(@config[:url_shortening][:url] + url).read
    url = !url.strip.empty? ? url : nil

    url
  end

  def onetime
    onetime_conf = @config[:onetime]

    onetime_api = Onetime::API.new onetime_conf[:email], onetime_conf[:api_key]

    options = { secret: Clipboard.paste, ttl: 7200 }
    options[:recipient] = onetime_conf[:email] if onetime_conf[:email] && @docopt['--email']

    onetime_api.post '/share', options
  end

  def onetime_url(secret_key)
    url = ONETIME_SECRET_BASE_URL + secret_key
    exit if @docopt['--email']
    url
  end

  def pws_offline
    puts 'PWSQR works offline!'.yellow
    exit unless system(@pws_command)

    generate_qr(Clipboard.paste)
  end

  def pws_online
    puts 'PWSQR works online!'.green
    pws

    secret = onetime
    raise OneTimeError, ERROR_MESSAGES[:onetime_wrong_response] unless secret['secret_key']

    short_url = shorten_url onetime_url secret['secret_key']
    raise UrlShorteningError, ERROR_MESSAGES[:url_shortener_wrong_response] unless short_url

    generate_qr(short_url)
  end
end

class OneTimeError < StandardError; end
class UrlShorteningError < StandardError; end

trap(:INT) do
  exit
end

LOGGER_LEVEL = PwsQrEnv::DEBUG ? PwsQrEnv::DEBUG : Logger::UNKNOWN

begin
  app = PwsQR.new(Logger, STDOUT, LOGGER_LEVEL)
  app.run
rescue Net::ReadTimeout, OpenURI::HTTPError, SocketError
  app.error PwsQR::ERROR_MESSAGES[:network_error]
rescue JSON::ParserError
  app.error PwsQR::ERROR_MESSAGES[:onetime_wrong_response]
rescue UrlShorteningError
  app.error PwsQR::ERROR_MESSAGES[:url_shortener_wrong_response]
rescue OneTimeError => e
  app.error e.message
rescue Docopt::Exit => e
  puts e.message
  puts
ensure
  Clipboard.copy(app.clipboard_backup)
end
