#! /usr/bin/env ruby

require 'docopt'
require 'clipboard'
require 'yaml'
require 'logger'
require 'open3'
require 'colorize'
require 'open-uri'
require 'onetime/api'

require_relative '../lib/pwsqr.rb'

# 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧 ☢️ UNDER CONSTRUCTION! ☢️ 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧 🚧

class PwsQR

  attr_reader :clipboard_backup

  DOCOPT = <<~DOC
    ======================================================
            Command-line QR tool for PWS gem 📲
    ======================================================

    Usage:
      #{PwsQrEnv::NAME} [--offline | --email] [--namespace <namespace>] <key>
      #{PwsQrEnv::NAME} --version
      #{PwsQrEnv::NAME} --help
      #{PwsQrEnv::NAME} --init

    Options:
      --version, -v                              Show the current app version
      --help, -h                                 Show this screen
      --init                                     Initialise new configuration
      --namespace <namespace>, -n <namespace>    Use custom pws namespace
      --offline, -o                              Force local password usage (disable OneTimeSecret if configured)
      --email, -e                                Send a friendly email containing the secret link
  DOC

  CONFIG_PATH = "#{Dir.home}/.#{PwsQrEnv::NAME}".freeze

  CONFIG_DEFAULTS = {
    onetime: {
      email: nil,
      api_key: nil
    },
    url_shortening: {
      url:'https://clck.ru/--?url='
    }
  }.freeze

  ONETIME_URL = 'https://onetimesecret.com/signup'.blue.freeze

  INITDOC = <<-INITDOC
    Initialising configuration… #{CONFIG_PATH.yellow}

    In order to use pwsqr online, please create your account here: #{ONETIME_URL}
    and setup your settings in #{CONFIG_PATH.yellow} config file. Thanks! >^.^<

    If you really wanted to use it offline — run the command with `--offline` flag!
  INITDOC

  ERROR_MESSAGES = {
    onetime_wrong_response: 'One-Time Secret didn\'t respond properly!',
    url_shortener_wrong_response: 'URL shortener didn\'t respond properly!',
    network_error: 'Network error occurred (probably there is no internet connection)!'
  }

  def initialize(logger_class, logger_device, logger_level)
    @logger = logger_class.new(logger_device)
    @logger.level = logger_level
  end

  def run
    @clipboard_backup = Clipboard.paste

    @docopt = Docopt.docopt(DOCOPT)

    @docopt['--namespace'] = @docopt['--namespace'] ? "-#{@docopt['--namespace']}" : ''
    @pws_command = "pws #{@docopt['--namespace']} get #{@docopt['<key>']} 0"

    load_config

    version if @docopt['--version']
    init_config if @docopt['--init']
    pwsqr if @docopt['<key>']

  rescue Docopt::Exit => e
    puts e.message
  end

  def error(message)
    puts "ERROR: #{message}".red
  end

  private

  def pwsqr
    if !is_config? || @docopt['--offline']
      pws_offline
    else
      pws_online
    end
  end

  def init_config
    @config ||= CONFIG_DEFAULTS
    File.open(CONFIG_PATH, "w").write(@config.to_yaml)

    print INITDOC
    exit
  end

  def version
    puts "#{PwsQrEnv::NAME.upcase} v.#{PwsQrEnv::VERSION}"
    exit
  end

  def load_config
    if(File.exists?(CONFIG_PATH))
      @config ||= YAML.load_file(CONFIG_PATH)
    else
      init_config
    end
  end

  def is_config?
    @config &&
    @config[:onetime][:email] &&
    @config[:onetime][:api_key] &&
    !@config[:url_shortening][:url].empty?
  end

  def generate_qr(str)
    result = nil

    Open3.popen3("qrcli", str)  {|i,o,e,t|
      result = o.read
    }

    result
  end

  def shorten_url(url)
    open(@config[:url_shortening][:url]+url).read
  end

  def pws_offline
    puts 'PWSQR works offline!'.yellow
    exit unless system(@pws_command)
    print generate_qr(Clipboard.paste)

    exit
  end

  def pws_online
    puts 'PWSQR works online!'.green
    exit unless system(@pws_command)

    onetime_api = Onetime::API.new @config[:onetime][:email], @config[:onetime][:api_key]

    options = { :secret => Clipboard.paste, :ttl => 7200 }
    options[:recipient] = @config[:onetime][:email] if @config[:onetime][:email] && @docopt['--email']

    secret = onetime_api.post '/share', options

    if secret && secret['secret_key']
      secret_url = 'https://onetimesecret.com/secret/' + secret['secret_key']
    else
      fail OneTimeError, ERROR_MESSAGES[:onetime_wrong_response]
    end

    short_url = shorten_url(secret_url)

    if short_url && !short_url.empty?
      print generate_qr(short_url)
    else
      fail UrlShorteningError, ERROR_MESSAGES[:url_shortener_wrong_response]
    end

    exit
  end
end

class OneTimeError < StandardError; end
class UrlShorteningError < StandardError; end

trap(:INT) do
  exit
end

LOGGER_LEVEL = PwsQrEnv::DEBUG ? PwsQrEnv::DEBUG : Logger::UNKNOWN

begin
  app = PwsQR.new(Logger, STDOUT, LOGGER_LEVEL)
  app.run
rescue SocketError
rescue Net::ReadTimeout
rescue OpenURI::HTTPError => e
  app.error PwsQR::ERROR_MESSAGES[:network_error]
rescue JSON::ParserError => e
  app.error PwsQR::ERROR_MESSAGES[:onetime_wrong_response]
rescue UrlShorteningError => e
  app.error PwsQR::ERROR_MESSAGES[:url_shortener_wrong_response]
rescue OneTimeError => e
  app.error e.message
rescue SystemExit
ensure
  Clipboard.copy(app.clipboard_backup)
end
